---
layout: post
title: "redis学习笔记"
description: ""
category: "技术" 
tags: "redis" 
---


### 1、基本操作函数

- 公共操作:exists type del ttl expire persist randomkey rename
- string:set/get mset/mget incr/incrby decr/decrby incrbyfloat append strlen(返回键值的长度)
- list:lpush/rpush lpop/rpop lrange ltrim brpop/blpop(阻塞式删除操作) rpoplpush/brpoplpush llen lindex lset linsert lrem   

		lrem key count value
		当count>0时，从列表左边开始删除前count个值为value的元素；
		当count<0时，从列表右边开始删除前|count|个值为value的元素；
		当count=0时，删除所有值为value的元素
list采用双向链表存储   
- hash:hset/hmset hget/hmget/hgetall hincrby hexists hsetnx(与hset类似，区别在于，如果字段已经存在，则不执行任何操作) hdel hkeys hlen
- set:sadd smembers sismember spop sunionstore(复制功能) scard(统计集合中元素数量) srandmember srem sdiff/sinter/sunion sdiffstore/sinterstore/sunionstore(把相应结果复制到指定key中)   
采用哈希表结果存储   
- sorted set:zadd zrange/zrevrange(withscores) zrangebyscore zrank/zrevrank(根据value查询位置) zrangebylex/zrevrangebylex zremrangebylex zlexcount zscore zincrby   
通过使用zadd来更新元素的score   
sorted set是采用跳表和哈希表来实现的，所以插入复杂度为O(log(N))。   
- bitmap:setbit getbit bitop bitcount bitpos   
Bitmap并不是Redis中的一种数据类型，是属于String类型的一种特殊结构，在一些统计场景中有却非常高效。Redis允许使用二进制数据的Key(binary keys) 和二进制数据的Value(binary values)。Bitmap就是二进制数据的value。Redis的 setbit(key, offset, value)操作对指定的key的value的指定偏移(offset)的位置1或0，时间复杂度是O(1)。
- hyperloglog:pfadd pfcount   
Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。   
在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

### 2、多数据库
redis每个数据库对外都是以一个从0开始的递增数字命名，redis默认支持16个数据库，可以通过配置参数databases来修改这个数字。客户端与redis建立连接后会自动选择0号数据库。

	redis>select 1
	OK
	redis[1]> GET test
	(nil)

首先，redis不支持自定义数据库的名字，每个数据库都以编号命名，开发中自己记录哪些数据库存储了哪些数据。另外，redis也不支持为每个数据库设置不同的访问密码，所有要么可以访问全部数据库，要么一个数据库也访问不了。最重要的是，多个数据库之间并不是完全隔离的，比如flushall命令可以清空一个redis实例中所有数据库中的数据。
由于redis非常轻量级，一个空redis实例占用的内存只有1MB左右，所以不用担心多个redis实例会额外占用很多内存。






 





