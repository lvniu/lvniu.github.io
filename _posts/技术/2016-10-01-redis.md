---
layout: post
title: "redis学习笔记"
description: ""
category: "技术" 
tags: "redis" 
---


### 1、基本操作函数

- 公共操作:exists type del ttl/pttl expire/pexpire persist randomkey rename   
expireat/pexpireat：expireat命令与expire命令的差别在于，前者使用unix时间作为第二个参数，表示键的生存时间的截止时间。pexpireat命令与expireat命令的区别是，前者的时间单位是毫秒。   
- string:set/get setex mset/mget incr/incrby decr/decrby incrbyfloat append strlen(返回键值的长度)
- list:lpush/rpush lpop/rpop lrange ltrim brpop/blpop(阻塞式删除操作) rpoplpush/brpoplpush llen lindex lset linsert lrem   

		lrem key count value
		当count>0时，从列表左边开始删除前count个值为value的元素；
		当count<0时，从列表右边开始删除前|count|个值为value的元素；
		当count=0时，删除所有值为value的元素
list采用双向链表存储   
- hash:hset/hmset hget/hmget/hgetall hincrby hexists hsetnx(与hset类似，区别在于，如果字段已经存在，则不执行任何操作) hdel hkeys hlen
- set:sadd smembers sismember spop sunionstore(复制功能) scard(统计集合中元素数量) srandmember srem sdiff/sinter/sunion sdiffstore/sinterstore/sunionstore(把相应结果复制到指定key中)   
采用哈希表结果存储   
- sorted set:zadd zrange/zrevrange(withscores) zrangebyscore zrank/zrevrank(根据value查询位置) zrangebylex/zrevrangebylex zremrangebylex zlexcount zscore zincrby   
通过使用zadd来更新元素的score   
sorted set是采用跳表和哈希表来实现的，所以插入复杂度为O(log(N))。   
- bitmap:setbit getbit bitop bitcount bitpos   
Bitmap并不是Redis中的一种数据类型，是属于String类型的一种特殊结构，在一些统计场景中有却非常高效。Redis允许使用二进制数据的Key(binary keys) 和二进制数据的Value(binary values)。Bitmap就是二进制数据的value。Redis的 setbit(key, offset, value)操作对指定的key的value的指定偏移(offset)的位置1或0，时间复杂度是O(1)。
- hyperloglog:pfadd pfcount   
Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。   
在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

### 2、多数据库
redis每个数据库对外都是以一个从0开始的递增数字命名，redis默认支持16个数据库，可以通过配置参数databases来修改这个数字。客户端与redis建立连接后会自动选择0号数据库。

	redis>select 1
	OK
	redis[1]> GET test
	(nil)

首先，redis不支持自定义数据库的名字，每个数据库都以编号命名，开发中自己记录哪些数据库存储了哪些数据。另外，redis也不支持为每个数据库设置不同的访问密码，所有要么可以访问全部数据库，要么一个数据库也访问不了。最重要的是，多个数据库之间并不是完全隔离的，比如flushall命令可以清空一个redis实例中所有数据库中的数据。
由于redis非常轻量级，一个空redis实例占用的内存只有1MB左右，所以不用担心多个redis实例会额外占用很多内存。

### 3、事务

	redis> multi
	OK
	redis> sadd test 1
	QUEUED
	redis> sadd test 2
	QUEUED
	redis> exec
	1) (integer) 1
	2) (integer) 1

如果在发送exec命令前，客户端断线了，则redis会清空事务队列，事务中的所用命令都不会执行。redis 的事务还能保证一个事务内的命令依次执行而不被其他命令插入。
redis实现事务的机制与常见的关系型数据库（例如mysql)不同，redis的事务不支持回滚，事务执行时会阻塞其他客户端的请求执行。
在客户端打开了事务标识后,只有命令:EXEC,DISCARD,WATCH,MULTI命令会被立即执行,其它命令服务器不会立即执行,而是将这些命令放入到一个事务队列里面,然后向客户端返回一个QUEUED回复 

- 语法错误 

		redis> multi
		OK
		redis> sadd test 3
		QUEUED
		redis> sadd test
		(error) ERR wrong number of arguments for 'sadd' command
		redis> exec
		(error) EXECABORT Transaction discarded because of previous errors.

在事务中，只要有一个命令有语法错误，执行exec命令后，redis就会直接返回错误，连语法正确的命令也不会执行。

- 运行错误

		redis> multi
		OK
		redis> sadd test 3
		QUEUED
		redis> set test 4
		QUEUED
		redis> sadd test 5
		QUEUED
		redis> exec
		1) (integer) 1
		2) OK
		3) (error) WRONGTYPE Operation against a key holding the wrong kind of value
		redis> smembers test
		(error) WRONGTYPE Operation against a key holding the wrong kind of value
		redis> get test
		"4"

这种错误，会有部分命令成功，需要注意。

- watch命令

watch命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到exec命令。
在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。

	redis> set test 1
	OK
	redis> watch test
	OK
	redis> set test 2
	OK
	redis> multi
	OK
	redis> set test 3
	QUEUED
	redis> exec
	(nil)
	redis> get test
	"2"

执行exec命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用unwatch命令来取消监控。   
如果使用watch命令检测了一个拥有生存时间的键，该键时间到期自动删除并不会被watch命令认为该键被改变。   

### 4、排序
- sort  
redis提供了sort命令，可以对列表类型、集合类型和有序集合类型键进行排序。   
sort命令还可以通过ALPHA参数实现按照字典顺序排列非数字元素，如果没有加ALPHA参数的话，sort命令会尝试将所有元素转换成双精度浮点数来比较，如果无法转换，则会提示错误。   

		redis> lpush test A E D T a w d l
		(integer) 8
		redis> sort test
		(error) ERR One or more scores can't be converted into double
		redis> sort test alpha
		1) "a"
		2) "A"
		3) "d"
		4) "D"
		5) "E"
		6) "l"
		7) "T"
		8) "w"

sort命令可以使用DESC参数，将 元素按照从大到小的顺序排列。

		redis> sort test alpha desc
		1) "w"
		2) "T"
		3) "l"
		4) "E"
		5) "D"
		6) "d"
		7) "A"
		8) "a"

sort还支持limit操作，例如：   

		redis> sort test alpha desc limit 2 4
		1) "l"
		2) "E"
		3) "D"
		4) "d"

by参数的语法为“by参考键”，其中参考键可以是字符串类型键或者散列类型键的某个字段（表示为键名->字段名）。sort命令将不再依据自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个“*”，并获取其值，然后依据该值对元素排序。例如：   

	redis> lpush test 1 2 3
	(integer) 3
	redis> set index:1 20
	OK
	redis> set index:2 12
	OK
	redis> set index:3 15
	OK
	redis> sort test by index:* desc
	1) "1"
	2) "3"
	3) "2"
当参考键名不包含“*”时（即常量键名，与元素值无关），sort命令将不会执行排序操作，因为redis认为这种情况没有意义。如果参考值相同，sort命令会再比较元素本身的值来决定元素的顺序。如果某个元素的参考键不存在，会默认参考键的值为0。   
参考键虽然支持散列类型，但是“*”只能在“->”符号前面才有用，在“->”后会被当成字段名本身，而不会作为占位符被元素的值替换。   
get参数不影响排序，它的作用是使sort命令的返回结果不再是元素自身的值，而是get参数中指定的键值。get参数也支持字符串类型和散列类型的键，并使用“*”作为占位符。一个sort命令中可以有多个get参数（而by参数只能有一个）。   
默认情况下，sort会直接返回排序结果，如果希望保存排序结果，可以使用store参数。例如，把结果保存到result键中：   

	redis> sort test by index:* desc store result
	(integer) 3
	redis> type result
	list
	redis> lrange result 0 -1
	1) "1"
	2) "3"
	3) "2"
保存后的键的类型是列表类型，如果键已经存在，则覆盖原有的值。   
sort命令的时间复杂度为O(n+mlogm)，其中n表示要排序的列表（集合或有序集合）中的元素个数，m表示要返回的元素个数。当n较大时，sort命令的性能相对较低，并且在排序前，会建立一个长度为n的容器来存储待排序的元素（比较占空间）。   
所以，开发中使用sort命令时，需要注意下面几点：  

	1）尽可能减少待排序键中元素的数量（使n尽可能小）；
	2）使用limit参数只获取需要的数据（使m尽可能小）；
	3）如果要排序的数据数量较大，尽可能使用store参数将结果缓存。
- sorted set插入时直接完成排序

### 5、消息通知

- 生产/消费模式   
通过redis实现消息通知，可以使用lpush/rpush、brpop/blpop(阻塞式删除操作)来实现。   
brpop/blpop有两个参数，第一个是键名，第二个是超时时间，单位为秒。当超过了此时间，仍然没有获得新元素的话，就会返回nil。如果超时间为0，表示不限制等待的时间。   
brpop/blpop可以同时监控多个键，键的先后顺序具有优先级。   

- 发布/订阅模式   

publish/subscribe

发布端：

	redis> publish test hi
	(integer) 0
订阅端：

	redis> subscribe test
	Reading messages... (press Ctrl-C to quit)
	1) "subscribe"
	2) "test"
	3) (integer) 1
	1) "message"
	2) "test"
	3) "hi1"

psubscribe命令订阅，支持glob峰哥通配符格式：

	redis> psubscribe test?*
	Reading messages... (press Ctrl-C to quit)
	1) "subscribe"
	2) "test"
	3) (integer) 1
	1) "message"
	2) "test"
	3) "hi1"
规则test?*可以匹配test1，test12，但不会匹配test   
psubscribe命令可以重复订阅一个频道。   
使用punsubscribe命令只能退订通过psubscribe命令订阅的规则，不会影响直接通过subscribe命令订阅的频道；同样，unsubscribe命令也不会影响通过psubscribe命令订阅的规则。

### 6、管道
客户端和redis使用tcp协议连接。在执行多条命令时，每条命令需要等待上一条命令执行完才能执行，即使命令不需要上一条命令的执行结果。   
redis的底层通信协议对管道（pipelining）提供了支持，通过管道可以一次性发送多条命令，并在执行完成后，一次性将结果返回。当一组命令中，每条命令都不依赖之前命令的执行结果，就可以将这组命令一起通过管道发出。   

	编码常量                    编码所对应的底层数据结构
	REDIS_ENCODING_INT	       long 类型的整数
	REDIS_ENCODING_EMBSTR	   embstr 编码的简单动态字符串
	REDIS_ENCODING_RAW	       简单动态字符串
	REDIS_ENCODING_HT	       字典
	REDIS_ENCODING_LINKEDLIST  双端链表
	REDIS_ENCODING_ZIPLIST	   压缩列表
	REDIS_ENCODING_INTSET	   整数集合
	REDIS_ENCODING_SKIPLIST	   跳跃表和字典

### 7、复制
redis复制功能，只需要在从从数据库的配置文件中加入“slaveof主数据库ip主数据库端口”即可，主数据库无需进行任何配置。使用slaveof no one命令将从数据库升级为主数据库。   
在默认情况下，从库是只读的。可以通过设置从库配置文件中的slave-read-only为no，可以使从库可写。但是，对从库的修更改，不会同步给其他任何数据库，并且，一旦主数据库更新，对应的数据就会覆盖从数据库中的改动。   
配置redis复制的时候，如果主库设置了密码，需要在从库配置文件中通过masterauth参数设置主库的密码，使从库链接主库时，自动使用auth命令认证。   

### 8、管理工具

- redis-cli

slowlog get命令：

	redis 10.138.65.29:6379> slowlog get
	 1) 1) (integer) 116
	    2) (integer) 1475485083
	    3) (integer) 289524
	    4)  1) "ZADD"
	        2) "203110771_0_0"
	        3) "0.0000000000000000"
	        4) "1410985851"
	        5) "0.0000000000000000"
	 2) 1) (integer) 115
	    2) (integer) 1475485083
	    3) (integer) 145643363
	    4)  1) "ZADD"
	        2) "203110771_0_0"
	        3) "0.0000000000000000"
	        4) "1387236798"
	        5) "0.0000000000000000"
	        6) "1387236799"
	        7) "0.0000000000000000"
	        8) "1387236800"
	        9) "0.0000000000000000"
	       10) "1387236801"
	       11) "0.0000000000000000"
	       12) "1387236802"
	       13) "0.0000000000000000"
	       14) "1387236803"
	       15) "0.0000000000000000"
	       16) "1387236804"
	       17) "0.0000000000000000"
	       18) "1387236805"
	       19) "0.0000000000000000"
	       20) "1387236806"
	       21) "0.0000000000000000"
	       22) "1387236807"
	       23) "0.0000000000000000"
	       24) "1387236808"
	       25) "0.0000000000000000"
	       26) "1387236809"
	       27) "0.0000000000000000"
	       28) "1387236810"
	       29) "0.0000000000000000"
	       30) "1387236811"
	       31) "0.0000000000000000"
	       32) "... (24971 more arguments)"

每条日志都有4个部分组成：   
1）该日志唯一ID；   
2）该命令执行的unix时间；   
3）该命令的耗时时间，单位为微妙（1s=1 000 000微妙）；   
4）命令及其参数。   

monitor命令：可以把任何执行的命令在redis-cli中打印出来，但是非常影响redis性能，一个客户端使用monitor命令，会降低redis将近一半的负载能力。   



 





