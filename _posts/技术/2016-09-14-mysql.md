---
layout: post
title: "mysql学习笔记"
description: ""
category: "技术" 
tags: "mysql" 
---


### 1、数据基本类型

- 整型

包括TINYINT/SMALLINT/MEDIUMINT/INT/BIGINT，分别使用8,16,24,32,64位的存储空间，可以表示有符号类型-2^(N-1)到2^(N-1)-1范围内的数据，或者无符号类型0到2^N-1范围内的数据，其中N是存储空间的位数。   
INT(11)，其中11表示显示的数值位数。int(M) zerofill，加上zerofill后M才表现出有点点效果，比如 int(3) zerofill,你插入到数据库里的是10,则实际插入为010,也就是在前面补充加了一个0.如果int(3)和int(10)不加 zerofill,则它们没有什么区别

- 浮点型

包括FLOAT/DOUBLE/DECIMAL   
FLOAT采用4个字节存储，DOUBLE采用8个字节存储，DECIMAL只是一种存储格式，在计算中DECIMAL会转换为DOUBLE类型。   
DECIMAL数据类型用于要求非常高的精确度的计算中，这些类型允许指定数值的精确度和计数方法作为选择参数。精确度在这里是指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的个数。例如，语句DECIMAL (5,2)规定了存储的值将不会超过5位数字，并且小数点后面有2位数字。

- 字符串

包括CHAR/VARCHAR  
VARCHAR是可变长度字符串，需要1或2个字节存储字符串长度，如果列的最大长度不大于255字节，，只是用1个字节表示，否则使用2个字节。最大可以表示65,533 bytes字节，剩下2个字节表示字符串长度。   
下面情况适合使用VARCHAR类型：

	1）字符串列的最大长度比平均长度大很多；
	2）列的更新很好，所以碎片不是问题；
	3）使用了像utf-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。   

VARCHAR(N)，其中N表示字符数（位数），无论是汉字，还是非汉字，都按字符数来计算。例如，VARCHAR(3)，可以插入'mmm','我爱你'等，但是，如果插入'mmmm','我真爱你',则会报错Data too long for column ...。   
InnoDB可以把过长的VARCHAR存储为BLOB。   
CHAR类型适合存储长度接近的字符串，例如MD5值。比较短的列、经常改变的列比较适合使用CHAR。   
CHAR和VARCHAR后面如果有空格，CHAR会自动去掉空格后存储，VARCHAR虽然不会去掉空格，但在进行字符串比较时，会去掉空格进行比较。   

- 二进制字符串

包括BINARY/VARBINARY   
跟普通字符串类型相似，区别是二进制字符串存储的是字节码，而不是字符。   
BINARY保存二进制字符串，它保存的是字节而不是字符，没有字符集限制。   
BINARY(N)可以保存N个字符，每个字符占1个字节，共占N个字节   
进行比较时是按字节进行比较，而不是按字符（char），按字节比较比字符简单快速。固定长度的 N 个字节二进制数据。N 必须从 1 到 8000。存储空间大小为 N+4 字节。   
按字符比较不区分大小写，而BINARY区分大小写，结尾使用\0填充，而不是空格。   
VARBINARY(N)，N个字节变长二进制数据。N必须从 1 到 8000。存储空间大小为实际输入数据长度 +4 个字节，而不是N个字节。输入的数据长度可能为 0 字节。后面不会补\0。   

- 文本类型

BLOB/TEXT：BLOB和TEXT列不能有默认值，可以查看[博客](http://blog.csdn.net/zuiaituantuan/article/details/6115938)   

### 2、ip地址存取
从IP转换为int地址分别是php的ip2long()和mysql的INET_ATON()，两个函数返回的结果是一样的，都是A*256*256*256+B*256*256+C*256+D的算法。   
从int转换为IP地址分别是php的long2ip()和mysql的INET_NTOA()。   
传统的方法，创建varchar(15)，需要占用15个字节，而改时使用int只需要4字节，可以省一些字节。

### 3、mysql schema设计中的陷阱
太多的列：mysql的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。   
关联太多的表：一个粗略的经验法则，如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。

### 4、索引
在mysql中，索引是在存储引擎层，而不是在服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。   
- InnoDB使用的是B+Tree结构建立的索引

B-Tree索引适用于全键值、键值范围或键前缀查找，其中键前缀只适用于根据最左前缀的查找。
例如表：

	CREATE TABLE books(
	    id int,
	    bookname varchar(30),
	    price double,
	    detail text not null,
	    fulltext(detail,bookname),
	    author varchar(30),
	    key(bookname, price, author),
	    primary key(id)
	);

B-Tree索引对下面类型的查询有效：   

	- 全值匹配：指的是和索引中的所有列进行匹配；例如可用于查找书名为'北京折叠'，价格为20，作为为'郝景芳'；
	- 匹配最左前缀：可以用于超找书名为'北京折叠'的书，即只是用索引的第一列；
	- 匹配列前缀：可以只匹配某一列的值的开头部分；例如查找'北京'开头的书名，只使用了索引的第一列；
	- 匹配范围值：即可以使用IN，例如书名IN('北京折叠', '三体'),这里也只使用了索引的第一列；
	- 精确匹配某一列并范围匹配另一列：查找书名为'北京折叠',并且价格以2开头的书，即第一列全匹配，第二列范围匹配。

总之：如果不是按照索引的最左列开始查找，则无法使用索引；不能跳过索引中的列；如果查询中有某个列的范围查找，则其右边所有列都无法使用索引优化查找。

- 哈希索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效。在mysql中，只有Memory引擎显式支持哈希索引。   
btree和hash索引的比较：http://www.cnblogs.com/vicenteforever/articles/1789613.html   
InnoDB引擎有一个特殊的功能叫做‘自适应哈希索引’。当InnoDB注意到某些索引值被使用的非常频繁时，他会在内存中基于B-tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。   
索引可以让查询锁定更少的行。   
mysql客户端和服务器之间的通信协议是‘半双工’的，即在任何时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。  

### 5、sql优化
- limit

		select * from ad_user order by id limit m,n;

随着m的增大，效率越来越低，因为每次查询都是先查询前m条记录，然后在扔掉，太浪费，可以调整为如下方式：

	select * from ad_user where id > m limit n;

### 6、游标
因为mysql游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以mysql在服务器端提供只读的、单向的游标。

### 7、复制
mysql的复制分为基于行的复制和基于语句的复制（逻辑复制）。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。   
基于语句的复制：优点：实现相当简单，相当于把主库执行的sql在备库重新执行一遍；二进制日志里的事件更加紧凑，能节省很多带宽；当主备库的模式不同时，逻辑复制能够在多种情况下工作（例如，主备库的表定义不同但数据类型相兼容、列的顺序不同等情况）缺点：因为主库上的数据更新除了执行语句外，可能还依赖于其他因素，例如主库和备库执行时间可能不同；另外一个问题是更新必须是串行的，所以需要更多的锁；如果正在使用触发器或者存储过程，就不要使用基于语句的复制模式。   
mysql能够在这两种复制模式之间动态切换，默认使用的是基于语句的复制，如果发现语句无法被正确的复制，就切换到基于行的复制。   
mysql复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，反之则不行，因为它可能无法解析新版本采用的新的特性或语法，另外所使用的二进制文件的格式也可能不相同。   
复制流程：

	1）在主库上把数据更改记录到二进制日志中；
	2）备库将主库上的日志复制到自己的中继日志中；
	3）备库读取中继日志中的事件，将其重放到备库数据之上。
其中步骤二的具体过程为：首先，备库会启动一个工作线程，成为I/O线程，I/O线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个二进制转储线程会读取主库上二进制日志中的事件。如果该线程追上了主库，它将进入休眠状态，直到主库发送信号量通知其有新的事件产生时才唤醒，备库I/O线程会将接收到的事件记录到中继日志中。







 





